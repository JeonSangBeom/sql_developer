-- 다중행(여러가지 행을 이용)
-- 주로 전체 갯수 구할때 / 평균값 구하기(급여)

--전체 합 구할 때
SELECT SUM(SAL) AS TOTAL
FROM EMP;

--평균 구할 때
SELECT TRUNC(AVG(SAL)) AS AVG
FROM EMP;

--제일 큰 숫자 뽑을 때
SELECT MAX(SAL) AS MAX
FROM EMP;

--제일 작은 숫자 뽑을 때
SELECT MIN(SAL) AS MIN
FROM EMP;

--총 갯수를 구할 때 - COMM은 사용하지 않는다 (NULL 값을 찾지 못함)
--보통 * 를 사용한다 - 제일 숫자가 많은 것을 갯수를 세게 된다
SELECT COUNT(*) AS COUNT
FROM EMP;

SELECT * FROM EMP;

--위에 하나씩 한 것을 한꺼번에 출력하기
SELECT SUM(SAL) AS SUM_TOTAL,
       TRUNC(AVG(SAL)) AS AVG,
       MAX(SAL) AS MAX,
       MIN(SAL) AS MIN,
       COUNT(*) AS TOTAL
FROM EMP;

-- DEPTNO(부서)가 30인 사람을 COUNT하게 하는 법
SELECT COUNT(*)
FROM EMP
WHERE DEPTNO = 30;

-- 30부서에 월급 제일 많이 받는 사람과 제일 작게 받는 사람...
SELECT MAX(SAL) AS MAX, MIN(SAL) AS MIN
FROM EMP
WHERE DEPTNO = 30;

-- 제일 최근에 입사한 사람
SELECT MAX(HIREDATE),MIN(HIREDATE)
FROM EMP;
--> MAX가 최근 MIN은 늦게

-- 각 부서별 평균 월급 구하기
SELECT TRUNC(AVG(SAL)), '10' AS DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT TRUNC(AVG(SAL)), '20' AS DEPTNO FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT TRUNC(AVG(SAL)), '30' AS DEPTNO  FROM EMP WHERE DEPTNO = 30;
--> 숫자면 숫자 문자면 문자('') 하나로 통일해여 오류 발생하지 않음

--오라클에서 제공하는 GROUP BY (위와 값 동일)
SELECT TRUNC(AVG(SAL)) AS AVG,
       DEPTNO 
       -->단일행 함수와 여러 행이 있는 함수는 같이 못쓴다(컬럼 갯수가 다르기 떄문) 이때 GROUP BY를 써주면 된다
FROM EMP
GROUP BY DEPTNO 
--> 부서별 그룹 시켜 따로 계산시 용이
ORDER BY AVG DESC;  -- ORDER BY 는 항상 제일 나중에

--부서별 직책 확인 
SELECT DEPTNO, JOB, TRUNC(AVG(SAL)) AS AVG, COUNT(JOB) AS COUNT
-->COUNT(JOB)/ (*)을 써도 된다 - 직책 갯수 
FROM EMP
GROUP BY DEPTNO, JOB --> 그룹을 부서랑 직책 둘다로 묶을 수 있다
ORDER BY DEPTNO, AVG;

-- HAVING(다중행) 절  GROUP을 써야지만 쓴다. / 그룹함수는 일반 값과 같이 못쓴다
SELECT DEPTNO, JOB, TRUNC(AVG(SAL)) AS AVG
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000 --> HAVING(조건,WHERE는 단일행일때만) 2000이상만 쓰고 싶을때 
ORDER BY DEPTNO, JOB;

--SELECT 기본순서 및 WHERR 사용시
SELECT DEPTNO, JOB, TRUNC(AVG(SAL)) AS AVG -- 컬럼명
FROM EMP -- 테이블 명
WHERE SAL <= 3000 --> 3000이하인 애들만 계산
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;


-- 부서별 직책 평균 급여가 1000이상인 사람들의 DEPTNO, JOB, TRUNC(AVG(SAL)) AS AVG 뽑아보기....
SELECT DEPTNO, JOB, TRUNC(AVG(SAL)) AS AVG
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 1000
ORDER BY DEPTNO, JOB;

--ROLLUP(JOB)- 계산결과를 끼워 넣는 것 (특정한 데이터를 말아 올려 표시하는 것)
SELECT JOB, SUM(SAL) AS SAL_TOTAL
FROM EMP
GROUP BY ROLLUP(JOB);

SELECT DEPTNO,JOB,SUM(SAL)
FROM EMP
GROUP BY ROLLUP(JOB,DEPTNO);

-- 보고서용
SELECT DEPTNO, JOB, COUNT(*) AS COUNT,MAX(SAL) AS HIGH,SUM(SAL) AS SUM_TOTAL, TRUNC(AVG(SAL)) AS AVG
FROM EMP
GROUP BY ROLLUP(DEPTNO,JOB) -- 그룹 DEPTNO와 JOB을 기준으로 단계별로 함계를 계싼해 준다
ORDER BY DEPTNO,JOB;

--GROUPING SET - 그룹을 하는데 나누어서 보여준다
SELECT DEPTNO, JOB, COUNT(*) AS COUNT
FROM EMP
GROUP BY GROUPING SETS(DEPTNO,JOB) -- 그룹이 따로 각자 합계를 보여준다
ORDER BY DEPTNO, JOB;

--빈괄호 및 NULL이나 ()를 사용하여 총 합계만 나타나게 해준다
SELECT DEPTNO, JOB, COUNT(*) AS COUNT
FROM EMP
GROUP BY GROUPING SETS((DEPTNO,JOB),()) --() 빈괄호 대신에 NULL을 써도 된다.
ORDER BY DEPTNO, JOB;

--GROUPING 0과 1로 나타내고 1이 총 합계를 뜻한다
SELECT DECODE(GROUPING(DEPTNO),1,'부서별 총합',DEPTNO) AS DEPT_NUMBER,
       DECODE(GROUPING(JOB),1,'직급별 총합',JOB) AS JOB_NUM,
       -->1로 표시되는 부분을 부서별, 직급별로 변경, 위치 JOB과 DEPTNO설정
DEPTNO, JOB, COUNT(*), MAX(SAL) AS HIGH, SUM(SAL) AS SUM_TOTAL, TRUNC(AVG(SAL)) AS AVG
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--DECODE 오라클에서만 쓰는 조건문

--LISTAGG 묶어서 옆으로 출력 (잘 쓰지는 않는다)
SELECT DEPTNO,
       LISTAGG(ENAME,',')  -- LISTAGG(합치는 컬럼명, 구분자) WITHIN GROUP ( ORDER BY 컬러명)
       WITHIN GROUP( ORDER BY SAL DESC) AS ENAMES --> 월급 많이 받는 사람순       
FROM EMP
GROUP BY DEPTNO;

SELECT * FROM EMP;

-- 옆으로 나열하기
SELECT LISTAGG(ENAME,'/') 
       WITHIN GROUP( ORDER BY ENAME) AS ENAMES
       -->이름을 옆으로 나열
FROM EMP
WHERE JOB IN ('MANAGER','SALESMAN'); --> 직업 안에 있는 사람만 뽑겠다


------------ TABLE 만드는 법 -----------------
DROP TABLE MONTH_SALES; -- > 테이블 삭제

CREATE TABLE MONTH_SALES ( --> 테이블 명
    PRODUCT_ID VARCHAR2(10), --> 컬럼명 / 데이터 타입(VARCHAR2(몇개 넣을수 있는지))
    MONTH VARCHAR2(10), --> VARCHAR2 : 문자 넣을때
    COMPANY VARCHAR2(20),
    MONEY NUMBER(10) --> NUMBER : 숫자넣을때
);


-- 만든 테이블에 데이터 넣는 법
INSERT INTO MONTH_SALES VALUES('P001','2021/12','SAMSUNG',10000);
INSERT INTO MONTH_SALES VALUES('P001','2021/11','SAMSUNG',12000);
INSERT INTO MONTH_SALES VALUES('P001','2021/10','SAMSUNG',15000);
INSERT INTO MONTH_SALES VALUES('P001','2021/09','SAMSUNG',18000);
INSERT INTO MONTH_SALES VALUES('P001','2021/08','SAMSUNG',9000);
--> INSERT INTO - 안으로 삽입
--> 그 다음 테이블 명  VALUES - 값
-->VARCHAR2 문자 / NUMBER 숫자 구분 해서 쓰기

INSERT INTO MONTH_SALES VALUES('P002','2021/12','APPLE',30000);
INSERT INTO MONTH_SALES VALUES('P002','2021/11','APPLE',19000);
INSERT INTO MONTH_SALES VALUES('P002','2021/10','APPLE',12000);
INSERT INTO MONTH_SALES VALUES('P002','2021/09','APPLE',13000);
INSERT INTO MONTH_SALES VALUES('P002','2021/08','APPLE',100000);


INSERT INTO MONTH_SALES VALUES('P003','2021/12','LG',12000);
INSERT INTO MONTH_SALES VALUES('P003','2021/11','LG',80000);
INSERT INTO MONTH_SALES VALUES('P003','2021/10','LG',101000);
INSERT INTO MONTH_SALES VALUES('P003','2021/09','LG',50000);
INSERT INTO MONTH_SALES VALUES('P003','2021/08','LG',19000);

--INSERT(추가) SELECT(읽어오는 것) UPDATE(수정)  DELETE(삭제)    CRUD(4개 합쳐서 이렇게 부른다)

--지울때는 DELETE
DELETE FROM MONTH_SALES;

ROLLBACK;--되살아나게 만들어 주다
COMMIT;--마무리

SELECT * FROM EMP;
SELECT * FROM MONTH_SALES;

SELECT PRODUCT_ID, MONTH, SUM(MONEY) AS TOTAL
FROM MONTH_SALES
-->GROUP BY 안쓰면 오류 발생(그룹과 단일행 함수를 같이 쓸수 없기 때문
GROUP BY rollup(PRODUCT_ID,MONTH);

--월별 (순서 변경)
SELECT MONTH, PRODUCT_ID,  SUM(MONEY) AS TOTAL
FROM MONTH_SALES
GROUP BY ROLLUP(MONTH,PRODUCT_ID);

--CUBE - 경우의 수를 전부 뽑아준다(복잡)
SELECT MONTH, PRODUCT_ID,  SUM(MONEY) AS TOTAL
FROM MONTH_SALES
GROUP BY CUBE(MONTH,PRODUCT_ID);

-- 위 복습
SELECT PRODUCT_ID, MONTH, COMPANY, SUM(MONEY) AS TOTAL
FROM MONTH_SALES
GROUP BY GROUPING SETS((PRODUCT_ID,MONTH),COMPANY);
--> ((PRODUCT_ID,MONTH),COMPANY) ID와 달을 그룹 - COMPANY로 함계


SELECT 
       CASE GROUPING(PRODUCT_ID) WHEN 1 THEN '모든 상품' ELSE PRODUCT_ID END AS PRODUCT_ID,
       CASE GROUPING(MONTH)      WHEN 1 THEN '모든 월'   ELSE MONTH END AS MONTH,
       SUM(MONEY) AS MONEY_TOTAL
FROM MONTH_SALES
GROUP BY ROLLUP(PRODUCT_ID,MONTH);

--오라클 에서만 사용 가능
--SELECT DECODE(GROUPING(DEPTNO):조건,1:참,'부서별 총합':참일 경우,DEPTNO:거짓일 경우) AS DEPT_NUMBER,
--       DECODE(GROUPING(JOB),1,'직급별 총합',JOB) AS JOB_NUM,
--DEPTNO, JOB, COUNT(*), MAX(SAL) AS HIGH, SUM(SAL) AS SUM_TOTAL, TRUNC(AVG(SAL)) AS AVG
--FROM EMP
--GROUP BY ROLLUP(DEPTNO, JOB)
--ORDER BY DEPTNO, JOB;





SELECT DEPTNO,JOB,MAX(SAL) AS HIGH
FROM EMP
GROUP BY DEPTNO,JOB
ORDER BY DEPTNO,JOB;

-- SELECT * FROM (피벗시킬 쿼리... 즉 세워 쓸 쿼리)
-- PIVOT(그룹함수(집계할 컬럼) FOR 피벗컬럼 IN (피벗 컬럼값 AS 별명)))
-- 로우와 컬럼을 바꿔 쓸 수 있다

SELECT *
FROM (SELECT DEPTNO , JOB , SAL FROM EMP)  -- 서브쿼리(쿼리 안 또 다른 쿼리)
PIVOT(MAX(SAL) FOR DEPTNO IN (10,20,30)) -->FOR(어디서)DEPTNO IN (안에서) 
ORDER BY JOB;



--복습
SELECT * FROM (SELECT DEPTNO , JOB , SAL FROM EMP)
PIVOT( MAX(SAL) FOR JOB IN (
                            'CLERK' AS 사원,
                            'SALESMAN' AS 영업사원,
                            'MANAGER' AS 관리자,
                            'ANALYST' AS 분석가,
                            'PRESIDENT' AS 사장
                           ))
ORDER BY DEPTNO;

--달별 입사인력을 뽑아보자....
--SELECT JOB,TO_CHAR(HIREDATE,'FMMM') AS HIRE_MONTH FROM EMP;

SELECT JOB,TO_CHAR(HIREDATE,'MM') AS HIRE_MONTH
FROM EMP
GROUP BY HIREDATE,JOB;

SELECT * FROM (SELECT JOB,TO_CHAR(HIREDATE,'FMMM') ||'월' AS HIRE_MONTH FROM EMP)
PIVOT( COUNT(*) FOR HIRE_MONTH IN ('1월','2월','3월','4월','5월','6월','7월','8월','9월','10월','11월','12월') );
-->||'월' -문자열을 더해준 이유는 월이란 컬럼이 존재하지 않기 때문에 값이 나오지 않기 때문이다
-->TO_CHAR(HIREDATE,'FMMM') -> FM : 1,2,3,4로 떨어지게 하기 위해 원래는 01,02,03으로 떨어졌다



----------------------------------------------PRACTICE---------------------------------------

SELECT DEPTNO , TRUNC(AVG(SAL)) AS AVG, MAX(SAL) AS MAX, MIN(SAL) AS MIN, COUNT(*) AS COUNT
FROM EMP
GROUP BY DEPTNO; -- 단일행 과 그룹행이 함께일땐 그룹으로 잡아줘야 한다

--3개 이상을 가지고 있는 직업 찾기
SELECT JOB, COUNT(*) AS COUNT
FROM EMP
GROUP BY JOB
HAVING COUNT(*) >= 3
ORDER BY COUNT;

--입사연도 기준으로 갯수 확인
SELECT TO_CHAR(HIREDATE,'YYYY') AS HIRE_YEAR,DEPTNO, COUNT(*) AS CNT
FROM EMP
GROUP BY TO_CHAR(HIREDATE,'YYYY'),DEPTNO
ORDER BY HIRE_YEAR;

--추가수당 받는 사람과 받지 않는 사람 찾기
SELECT NVL2(COMM,'O','X') AS EXIST_COMM, COUNT(*) AS CNT
FROM EMP
GROUP BY NVL2(COMM,'O','X');

--중간 결과 값(부서(총)와 입사연도)
SELECT DEPTNO,
       TO_CHAR(HIREDATE,'YYYY') AS HIRE_YEAR,
       COUNT(*) AS CNT,
       MAX(SAL) AS MAX_SAL,
       SUM(SAL) AS SUM_SAL,
       TRUNC(AVG(SAL)) AS AVG_SAL
FROM EMP
GROUP BY ROLLUP(DEPTNO,TO_CHAR(HIREDATE,'YYYY'));



---------------TABLE ---------------
--조인 -  테이블 두개 연결해서 사용
SELECT * 
FROM EMP,DEPT; --> 행과 열만 있으면 다 올 수 있다

--조건 필요
SELECT * 
FROM  EMP E , DEPT D --> 별명 생성
WHERE E.DEPTNO = D.DEPTNO; --> 컬럼명 앞에 테이블 명(별명)을 붙여 쓸 수 있다


-- INNER JOIN : 두개를 붙여서 쓰는 (교차해서 쓰는 조인)
SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO --> 두개가 같을 경우만 출력
ORDER BY D.DEPTNO DESC, E.EMPNO ASC; 

-- 하나만 있는 컬럼명은 테이블명 생략 가능
SELECT EMPNO, ENAME, D.DEPTNO, DNAME, LOC 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND SAL >= 2500
ORDER BY D.DEPTNO DESC, E.EMPNO ASC;


-- 비 등가(서로 같은 것이 없는 것) 조인--
SELECT * 
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL; 
-->E.SAL BETWEEN(어디어디 사이에) S.LOSAL AND S.HISAL(이 두개 사이)

SELECT * 
FROM EMP E, SALGRADE S
WHERE E.SAL = S.HISAL;

---- SELF JOIN---- 자기가 자기를 한번 더 쓰기....
SELECT E1.EMPNO,E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_NO,
       E2.ENAME AS MGR_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;


SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_NO,
       E2.ENAME AS MGR_NAME
FROM EMP E1,EMP E2
WHERE E1.MGR = E2.EMPNO(+)  -- LEFT(기준열이 왼쪽) OUTER JOIN(외부조인) 은 대상 테이블에 값이 없어도 들고와라
ORDER BY E1.EMPNO;          -- 상급자가 없는 경우도 출력(조건에 만족되는 것이 없어도)


SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_NO,
       E2.ENAME AS MGR_NAME
FROM EMP E1,EMP E2
WHERE E1.MGR(+) = E2.EMPNO  -- RIGHT OUTER JOIN 은 대상 테이블에 값이 없어도 들고와라...
ORDER BY E1.EMPNO;          -- 자기가 관리자가 아닌 사람



----- ANSI JOIN(표준조인 - 다른 곳에서도 사용 가능 (MY SQL 외)) --------
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D;
--ORDER BY DEPTNO, E.EMPNO; - 안써도 똑같다
--공통인 것은 테이블 명을 안붙이고 사용 
--FROM절에 사용

-- NATURAL JOIN 말고 다른 방법
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D USING (DEPTNO)
ORDER BY DEPTNO, E.EMPNO;


-- 등가조인 이고 이너조인(교집합)인 것
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
WHERE SAL < 3000
ORDER BY DEPTNO, E.EMPNO;
--> 이경우는 DEPTNO앞에 테이블명 입력
--> ON : 조건 (가장 많이 사용한다)

----LEFT OUTER JOIN 다른 방법 -----
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_NO,
       E2.ENAME AS MGR_NAME
FROM EMP E1 LEFT OUTER JOIN  EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;          -- 상급자가 없는 경우도 출력.....

----RIGHT OUTER JOIN -----
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_NO,
       E2.ENAME AS MGR_NAME
FROM EMP E1 RIGHT OUTER JOIN  EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;          

----FULL OUTER JOIN : 둘다 출력 -----
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_NO,
       E2.ENAME AS MGR_NAME
FROM EMP E1 FULL OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;         




--------------------------------------------8장 문제 풀이------------------------
--   8-1 ORACLE
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 2000;

--SELECT DEPTNO, D.DNAME,E.EMPNO, E.ENAME,E.SAL
--FROM EMP E NATURAL JOIN DEPT D
--WHERE E.SAL > 2000;  -> FROM 절 사용 법

--   8-1 ANSI
SELECT D.DEPTNO, D.DNAME,E.EMPNO, E.ENAME,E.SAL
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO )
WHERE E.SAL > 2000;


-- 8-2 ORACLE
SELECT D.DEPTNO, D.DNAME, 
       TRUNC(AVG(E.SAL)) AS AVG_SAL,
       MAX(E.SAL) AS MAX_SAL,
       MIN(E.SAL) AS MIN_SAL,
       COUNT(*) AS CNT
FROM EMP E ,DEPT D
WHERE E.DEPTNO = D.DEPTNO
GROUP BY D.DEPTNO, D.DNAME;

-- 8-2 ANSI
SELECT D.DEPTNO, D.DNAME, 
       TRUNC(AVG(E.SAL)) AS AVG_SAL,
       MAX(E.SAL) AS MAX_SAL,
       MIN(E.SAL) AS MIN_SAL,
       COUNT(*) AS CNT
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO )
GROUP BY D.DEPTNO, D.DNAME;
       
--  8-3 ORACLE
SELECT D.DEPTNO,D.DNAME,E.EMPNO,E.ENAME,E.JOB,E.SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO -- 오른쪽에 있으면 왼쪽에 없어도 출력
ORDER BY E.DEPTNO, E.ENAME;

--  8-3 ANSI
SELECT D.DEPTNO,D.DNAME,E.EMPNO,E.ENAME,E.JOB,E.SAL
FROM EMP E RIGHT OUTER JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
ORDER BY E.DEPTNO, E.ENAME;












